<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Annoying Pixel — TG WebApp</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0; padding: 16px;
      font-family: Arial, Helvetica, sans-serif;
      text-align: center;
      user-select: none; -webkit-user-select: none;
      background: #f6f6f6;
    }
    #hud { margin: 6px auto 10px; font-size: 14px; }
    .btns { margin: 8px 0 14px; display: flex; gap: 8px; justify-content: center; }
    button {
      cursor: pointer; padding: 8px 12px; border-radius: 8px;
      border: 1px solid #999; background: #fff; font-size: 14px;
    }
    button:disabled { opacity: .5; cursor: not-allowed; }
    #container { display: inline-block; position: relative; }
    canvas { border: 1px solid #000; touch-action: none; background: #000; display: block; }
    #message {
      position: absolute; inset: 0; display: none; align-items: center; justify-content: center;
      backdrop-filter: blur(2px); background: #00000040; color: #fff; font-size: 22px; font-weight: 700;
      text-shadow: 0 1px 2px #000; padding: 16px;
    }
  </style>
</head>
<body>
  <div id="hud">—</div>
  <div class="btns">
    <button id="restartBtn" title="Перезапуск">⟲</button>
  </div>

  <div id="container">
    <canvas id="game" width="400" height="400"></canvas>
    <div id="message"></div>
  </div>

  <script>
    // Типы клеток
    const BLACK = 0, WHITE = 1, RED = 2;

    // Параметры поля
    const gridSize = 50;
    const pixelSize = 8; // CSS-пиксели
    const totalPixels = gridSize * gridSize;

    // Тайминги
    const GAME_TIME_SEC = 180;
    const DRAW_WINDOW_MS = 20000; // 20 сек рисования после клика по красному
    const RED_LIFE_MS_MIN = 1500;
    const RED_LIFE_MS_MAX = 3000;
    const RED_RESPAWN_MIN = 1200;
    const RED_RESPAWN_MAX = 2400;

    // Шум (небольшой)
    const NOISE_PER_SECOND = 3;

    // DOM
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hudEl = document.getElementById('hud');
    const msgEl = document.getElementById('message');
    const restartBtn = document.getElementById('restartBtn');

    // Состояние
    let grid = [];
    let cleared = 0;
    let timeLeft = 0;

    // Рисование
    let painting = false;
    let drawEnabled = false;  // разрешён ли режим "кисть"
    let drawEnableTimeout = null;

    // Таймеры
    let timerInterval = null;
    let noiseInterval = null;
    let redSpawnTimeout = null;
    const activeReds = new Map(); // key -> timeoutId

    // Утилиты
    const keyOf = (x,y) => y*gridSize + x;
    const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
    const clamp = (n,a,b) => Math.max(a, Math.min(b, n));

    // HiDPI
    function setupHiDPI() {
      const dpr = window.devicePixelRatio || 1;
      const css = gridSize * pixelSize; // 400
      canvas.style.width = css+'px';
      canvas.style.height = css+'px';
      canvas.width = Math.floor(css*dpr);
      canvas.height = Math.floor(css*dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    // Координаты
    function getCellFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = (gridSize*pixelSize)/rect.width;
      const scaleY = (gridSize*pixelSize)/rect.height;
      const cx = Math.floor(((e.clientX - rect.left)*scaleX)/pixelSize);
      const cy = Math.floor(((e.clientY - rect.top)*scaleY)/pixelSize);
      return { x: clamp(cx,0,gridSize-1), y: clamp(cy,0,gridSize-1) };
    }

    // Рендер
    function drawCell(x,y) {
      const st = grid[y][x];
      if (st === BLACK) ctx.fillStyle = '#000';
      else if (st === WHITE) ctx.fillStyle = '#fff';
      else if (st === RED)   ctx.fillStyle = '#e10600';
      ctx.fillRect(x*pixelSize, y*pixelSize, pixelSize, pixelSize);
    }
    function drawGridFull() {
      for (let y=0;y<gridSize;y++)
        for (let x=0;x<gridSize;x++) drawCell(x,y);
    }

    // HUD — компактный
    function updateHUD() {
      const pct = ((cleared/totalPixels)*100).toFixed(1);
      const m = Math.floor(timeLeft/60), s = timeLeft%60;
      const t = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
      const pen = drawEnabled ? ` ✏️${Math.ceil(remainingDrawSeconds())}s` : '';
      hudEl.textContent = `✔ ${pct}%  ⏱ ${t}${pen}`;
    }
    function remainingDrawSeconds() {
      if (!drawEnabled || !drawEnableTimeout) return 0;
      return Math.max(0, drawEnableTimeout.when - Date.now())/1000;
    }

    // Сообщения
    function showMsg(text) { msgEl.textContent = text; msgEl.style.display = 'flex'; }
    function hideMsg() { msgEl.style.display = 'none'; msgEl.textContent = ''; }

    // Изменения клетки
    function toWhite(x,y) {
      const st = grid[y][x];
      if (st === WHITE) return false;
      if (st === RED) {
        const id = activeReds.get(keyOf(x,y));
        if (id) { clearTimeout(id); activeReds.delete(keyOf(x,y)); }
        // Включаем рисование на 20 сек
        activateDrawWindow();
      }
      grid[y][x] = WHITE;
      cleared++;
      drawCell(x,y);
      return true;
    }
    function toBlack(x,y) {
      const st = grid[y][x];
      if (st === WHITE) cleared = Math.max(0, cleared-1);
      if (st === RED) {
        const id = activeReds.get(keyOf(x,y));
        if (id) { clearTimeout(id); activeReds.delete(keyOf(x,y)); }
      }
      grid[y][x] = BLACK;
      drawCell(x,y);
    }

    // Игровые действия
    function onCellAction(x,y) {
      if (timeLeft <= 0) return;

      const st = grid[y][x];

      // Красный — очищаем и активируем рисование
      if (st === RED) { toWhite(x,y); afterChange(); return; }

      // Обычный клик всегда очищает одну чёрную
      if (st === BLACK) { toWhite(x,y); afterChange(); return; }

      // Белая — ничего
    }
    function onCellDrag(x,y) {
      // При рисовании разрешаем “мазать” только если окно активно
      if (!drawEnabled) return;
      if (grid[y][x] === BLACK) { toWhite(x,y); afterChange(); }
    }
    function afterChange() {
      updateHUD();
      checkWin100();
    }

    function activateDrawWindow() {
      drawEnabled = true;
      if (drawEnableTimeout) clearTimeout(drawEnableTimeout.id);
      const when = Date.now() + DRAW_WINDOW_MS;
      const id = setTimeout(() => { drawEnabled = false; updateHUD(); }, DRAW_WINDOW_MS);
      drawEnableTimeout = { id, when };
      updateHUD();
    }

    // Красные пиксели
    function spawnRed() {
      // ограничим кол-во активных до 3
      if (activeReds.size >= 3) return;

      let x=0,y=0,ok=false,tries=0;
      while(tries<400 && !ok) {
        x=randInt(0,gridSize-1); y=randInt(0,gridSize-1);
        if (grid[y][x] === BLACK) ok=true;
        tries++;
      }
      if (!ok) return;

      grid[y][x] = RED; drawCell(x,y);
      const k = keyOf(x,y);
      const life = randInt(RED_LIFE_MS_MIN, RED_LIFE_MS_MAX);
      const tid = setTimeout(() => {
        if (grid[y][x] === RED) {
          activeReds.delete(k);
          // Штраф: крест из 5 чёрных (перекрашиваем даже белые)
          grid[y][x] = BLACK; drawCell(x,y);
          const dirs = [[0,0],[1,0],[-1,0],[0,1],[0,-1]];
          for (const [dx,dy] of dirs) {
            const nx=x+dx, ny=y+dy;
            if (nx>=0&&nx<gridSize&&ny>=0&&ny<gridSize) toBlack(nx,ny);
          }
          updateHUD();
        }
      }, life);
      activeReds.set(k, tid);
    }
    function scheduleNextRed() {
      const delay = randInt(RED_RESPAWN_MIN, RED_RESPAWN_MAX);
      redSpawnTimeout = setTimeout(() => { spawnRed(); scheduleNextRed(); }, delay);
    }

    // Шум: часть белых снова становятся чёрными
    function applyNoise(n) {
      let changed = 0, tries = 0;
      while (changed < n && tries < n*80) {
        const x = randInt(0,gridSize-1), y = randInt(0,gridSize-1);
        if (grid[y][x] === WHITE) { toBlack(x,y); changed++; }
        tries++;
      }
      if (changed) updateHUD();
    }

    // Победа = 100%
    function checkWin100() {
      if (cleared >= totalPixels) endGame(true);
    }

    // Таймер
    function startTimer() {
      timerInterval = setInterval(() => {
        timeLeft--; updateHUD();
        if (timeLeft <= 0) endGame(false);
      }, 1000);
    }

    function showCrack() {
      ctx.save();
      ctx.strokeStyle = 'rgba(220,220,220,0.9)'; ctx.lineWidth = 4;
      ctx.beginPath(); ctx.moveTo(60,70); ctx.lineTo(180,190); ctx.lineTo(320,140);
      ctx.moveTo(40,320); ctx.lineTo(160,260); ctx.lineTo(260,360); ctx.stroke();
      ctx.restore();
    }

    // Жизненный цикл
    function resetGrid() {
      grid = Array.from({length:gridSize}, () => Array(gridSize).fill(BLACK));
      cleared = 0;
      drawEnabled = false;
      if (drawEnableTimeout) { clearTimeout(drawEnableTimeout.id); drawEnableTimeout = null; }
      activeReds.forEach(id => clearTimeout(id)); activeReds.clear();
    }

    function startGame() {
      // Сброс таймеров
      clearInterval(timerInterval); clearInterval(noiseInterval); clearTimeout(redSpawnTimeout);
      activeReds.forEach(id => clearTimeout(id)); activeReds.clear();

      resetGrid(); hideMsg();
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawGridFull();

      timeLeft = GAME_TIME_SEC;
      updateHUD();

      startTimer();
      noiseInterval = setInterval(() => applyNoise(NOISE_PER_SECOND), 1000);
      scheduleNextRed();

      telegramMainButton('⟲', () => startGame());
    }

    function endGame(win) {
      clearInterval(timerInterval); clearInterval(noiseInterval); clearTimeout(redSpawnTimeout);
      activeReds.forEach(id => clearTimeout(id)); activeReds.clear();

      if (win) {
        showMsg('WIN!');
      } else {
        showCrack();
        showMsg('GAME OVER');
      }
      updateHUD();
      telegramMainButton('⟲', () => startGame());
    }

    // Pointer-события
    canvas.addEventListener('pointerdown', (e) => {
      if (timeLeft <= 0) return;
      painting = true; canvas.setPointerCapture(e.pointerId);
      const {x,y} = getCellFromEvent(e);
      onCellAction(x,y); // одиночное действие всегда доступно
    });
    canvas.addEventListener('pointermove', (e) => {
      if (!painting) return;
      const {x,y} = getCellFromEvent(e);
      onCellDrag(x,y); // “мазать” можно только в окне рисования
    });
    canvas.addEventListener('pointerup',   () => { painting = false; });
    canvas.addEventListener('pointercancel', () => { painting = false; });

    // Кнопка UI
    restartBtn.addEventListener('click', () => startGame());

    // Telegram
    function telegramMainButton(text, onClick) {
      const tg = window.Telegram && window.Telegram.WebApp;
      if (!tg) return;
      tg.MainButton.hide();
      tg.MainButton.setText(text);
      tg.MainButton.show();
      tg.MainButton.offClick && tg.MainButton.offClick();
      tg.MainButton.onClick(onClick);
    }
    function integrateWithTelegram() {
      const tg = window.Telegram && window.Telegram.WebApp;
      if (!tg) return;
      tg.ready(); tg.expand();
      const bg = tg.themeParams?.bg_color; if (bg) document.body.style.background = `#${bg}`;
      telegramMainButton('⟲', () => startGame());
    }

    // Init
    (function init(){
      setupHiDPI();
      resetGrid();
      drawGridFull();
      updateHUD();
      integrateWithTelegram();
      startGame();
    })();
  </script>
</body>
</html>
