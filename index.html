<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Annoying Pixel — TG WebApp</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0; padding: 16px;
      font-family: Arial, Helvetica, sans-serif;
      text-align: center;
      user-select: none; -webkit-user-select: none;
      background: #f6f6f6;
      transition: background 0.3s;
    }
    #hud { margin: 6px auto 10px; font-size: 14px; }
    .btns { margin: 8px 0 14px; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }
    button {
      cursor: pointer; padding: 8px 12px; border-radius: 8px;
      border: 1px solid #999; background: #fff; font-size: 14px;
    }
    button:disabled { opacity: .5; cursor: not-allowed; }
    #container { display: inline-block; position: relative; max-width: 100%; }
    canvas { border: 1px solid #000; touch-action: none; background: #000; display: block; max-width: 100%; height: auto; }
    #message {
      position: absolute; inset: 0; display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.4); color: #fff; font-size: 22px; font-weight: 700;
      text-shadow: 0 1px 2px #000; padding: 16px;
      /* Fallback for backdrop-filter */
      backdrop-filter: blur(2px); -webkit-backdrop-filter: blur(2px);
    }
    @supports not (backdrop-filter: blur(2px)) {
      #message { background: rgba(0,0,0,0.8); }
    }
  </style>
</head>
<body>
  <div id="hud">—</div>
  <div class="btns">
    <button id="restartBtn" title="Restart">⟲</button>
  </div>

  <div id="container">
    <canvas id="game" width="400" height="400"></canvas>
    <div id="message"></div>
  </div>

  <script>
    // ==================== КОНСТАНТЫ И НАСТРОЙКИ ====================
    const BLACK = 0, WHITE = 1, RED = 2, BLUE = 5;
    const gridSize = 50;
    const pixelSize = 8;
    const totalPixels = gridSize * gridSize;
    const GAME_TIME_SEC = 90; // Сокращено до 1,5 минуты (было 180)
    const DRAW_WINDOW_MS = 20000;
    const BOMB_LIFE_MS_MIN = 3000;
    const BOMB_LIFE_MS_MAX = 5000;
    const BONUS_RESPAWN_MIN = 3000; // Уменьшено на 40% (было 5000)
    const BONUS_RESPAWN_MAX = 6000; // Уменьшено на 40% (было 10000)
    const BLUE_LIFE_MS_MIN = 8000; // Изменено на 8 секунд
    const BLUE_LIFE_MS_MAX = 8000; // Изменено на 8 секунд
    const BLUE_RESPAWN_MIN = 8000;
    const BLUE_RESPAWN_MAX = 15000;
    const NOISE_PER_SECOND = 3;
    const LANG = 'en'; // Всегда английский
    const TEXTS = {
      ru: { win: 'ПОБЕДА!', gameOver: 'ИГРА ОКОНЧЕНА', restart: '⟲', pause: '⏸️', resume: '▶️' },
      en: { win: 'WIN!', gameOver: 'GAME OVER', restart: '⟲', pause: '⏸️', resume: '▶️' }
    };
    // Новые константы для динамического звука
    const BASE_FREQ = 200;
    const SPEED_MULTIPLIER = 50;
    const SOUND_THROTTLE_MS = 50;

    // ==================== DOM ЭЛЕМЕНТЫ ====================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hudEl = document.getElementById('hud');
    const msgEl = document.getElementById('message');
    const restartBtn = document.getElementById('restartBtn');

    // ==================== СОСТОЯНИЕ ИГРЫ ====================
    let grid = [];
    let cleared = 0;
    let timeLeft = 0;
    let painting = false;
    let drawEnabled = true; // По умолчанию включено
    let drawEnableTimeout = null;
    let isPaused = false;
    let animationFrameId = null;
    // Новые переменные для скорости мыши
    let lastTime = 0;
    let lastX = 0;
    let lastY = 0;
    let lastSoundTime = 0;

    // Таймеры
    let timerInterval = null;
    let noiseInterval = null;
    let bonusSpawnTimeout = null;
    let blueSpawnTimeout = null;
    const activeBombs = new Map();
    const activeBlues = new Map();

    // Кэширование для оптимизации
    const cssSize = gridSize * pixelSize;

    // ==================== УТИЛИТЫ ====================
    /**
     * Генерирует ключ для клетки.
     * @param {number} x - X-координата.
     * @param {number} y - Y-координата.
     * @returns {number} Ключ.
     */
    const keyOf = (x, y) => y * gridSize + x;

    /**
     * Случайное целое число в диапазоне.
     * @param {number} a - Минимум.
     * @param {number} b - Максимум.
     * @returns {number} Случайное число.
     */
    const randInt = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;

    /**
     * Ограничивает число в диапазоне.
     * @param {number} n - Число.
     * @param {number} a - Минимум.
     * @param {number} b - Максимум.
     * @returns {number} Ограниченное число.
     */
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

    // ==================== ЗВУКИ (Web Audio API) ====================
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSound(frequency, duration = 200) {
      if (!audioCtx || audioCtx.state !== 'running') return;
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
      gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration / 1000);
      oscillator.start(audioCtx.currentTime);
      oscillator.stop(audioCtx.currentTime + duration / 1000);
    }

    // ==================== HiDPI И АДАПТИВНОСТЬ ====================
    function setupHiDPI() {
      const dpr = window.devicePixelRatio || 1;
      const containerWidth = Math.min(window.innerWidth - 32, 600); // Адаптивность
      const scale = Math.max(containerWidth / cssSize, 0.75); // Минимум 75%
      const scaledSize = cssSize * scale;
      canvas.style.width = scaledSize + 'px';
      canvas.style.height = scaledSize + 'px';
      canvas.width = Math.floor(scaledSize * dpr);
      canvas.height = Math.floor(scaledSize * dpr);
      ctx.setTransform(dpr * scale, 0, 0, dpr * scale, 0, 0);
    }

    // ==================== КООРДИНАТЫ ====================
    function getCellFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = cssSize / rect.width;
      const scaleY = cssSize / rect.height;
      const cx = Math.floor(((e.clientX - rect.left) * scaleX) / pixelSize);
      const cy = Math.floor(((e.clientY - rect.top) * scaleY) / pixelSize);
      return { x: clamp(cx, 0, gridSize - 1), y: clamp(cy, 0, gridSize - 1) };
    }

    // ==================== РЕНДЕР ====================
    function drawCell(x, y, isAnimated = false) {
      const st = grid[y][x];
      let color = st === BLACK ? '#000' : st === WHITE ? '#fff' : st === RED ? '#e10600' : st === BLUE ? '#0000ff' : '#000';
      if (isAnimated && st === BLACK) color = '#fff'; // Для чёрных пикселей во время анимации делаем белыми для видимости
      ctx.fillStyle = color;
      ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
    }

    function drawGridFull() {
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          drawCell(x, y);
        }
      }
    }

    function render() {
      if (!isPaused) {
        animationFrameId = requestAnimationFrame(render);
      }
    }

    // ==================== HUD ====================
    function updateHUD() {
      const pct = ((cleared / totalPixels) * 100).toFixed(1);
      const m = Math.floor(timeLeft / 60), s = timeLeft % 60;
      const t = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
      const pen = drawEnabled ? ` ✏️∞` : ''; // Бесконечно, поскольку всегда включено
      hudEl.textContent = `✔ ${pct}%  ⏱ ${t}${pen}`;
    }

    // ==================== СООБЩЕНИЯ ====================
    function showMsg(text) { msgEl.textContent = text; msgEl.style.display = 'flex'; }
    function hideMsg() { msgEl.style.display = 'none'; msgEl.textContent = ''; }

    // ==================== ИЗМЕНЕНИЯ КЛЕТОК ====================
    function toWhite(x, y, isDrag = false) {
      const st = grid[y][x];
      if (st === WHITE) return false;
      if (st === RED) {
        const id = activeBombs.get(keyOf(x, y));
        if (id) { clearTimeout(id); activeBombs.delete(keyOf(x, y)); }
        grid[y][x] = WHITE;
        cleared++;
        drawCell(x, y);
        playSound(100, 300); // Глухой звук взрыва (низкая частота)
        animateExplosion(x, y); // Анимированный взрыв
        return true; // Ранний return, чтобы не дублировать ниже
      } else if (st === BLUE) {
        const id = activeBlues.get(keyOf(x, y));
        if (id) { clearTimeout(id); activeBlues.delete(keyOf(x, y)); }
        timeLeft += 3; // Сокращено с 10 до 3
        updateHUD();
        playSound(400);
      }
      if (st !== RED) { // Для синего и чёрного
        grid[y][x] = WHITE;
        cleared++;
        drawCell(x, y);
        playSound(600);
      }
      return true;
    }

    function toBlack(x, y) {
      const st = grid[y][x];
      if (st === WHITE) cleared = Math.max(0, cleared - 1);
      if (st === RED) {
        const id = activeBombs.get(keyOf(x, y));
        if (id) { clearTimeout(id); activeBombs.delete(keyOf(x, y)); }
      } else if (st === BLUE) {
        const id = activeBlues.get(keyOf(x, y));
        if (id) { clearTimeout(id); activeBlues.delete(keyOf(x, y)); }
      }
      grid[y][x] = BLACK;
      drawCell(x, y);
    }

    // ==================== АНИМИРОВАННЫЙ ВЗРЫВ КРАСНОГО ====================
    function animateExplosion(cx, cy) {
      const explosionPixels = [];
      for (let dy = -3; dy <= 3; dy++) {
        for (let dx = -3; dx <= 3; dx++) {
          if (dx * dx + dy * dy <= 9) {
            const nx = cx + dx, ny = cy + dy;
            if ((nx !== cx || ny !== cy) && nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && grid[ny][nx] !== WHITE && grid[ny][nx] !== RED) {
              const dist = Math.sqrt(dx * dx + dy * dy);
              explosionPixels.push({ x: nx, y: ny, dist });
            }
          }
        }
      }
      explosionPixels.sort((a, b) => a.dist - b.dist); // Сортировка по расстоянию

      drawGridFull(); // Рисуем сетку один раз перед анимацией
      animatePixelExplosion(explosionPixels);

      // После завершения анимаций закрасить пиксели и перерисовать
      setTimeout(() => {
        explosionPixels.forEach(pixel => {
          toWhite(pixel.x, pixel.y, true);
        });
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Полная очистка Canvas
        drawGridFull(); // Перерисовка сетки
      }, 900);
    }

    function animatePixelExplosion(pixels) {
      const startTime = Date.now();
      const duration = 800; // мс на анимацию
      const delayPerDist = 50; // Задержка на единицу расстояния

      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        pixels.forEach(pixel => {
          const pixelStart = pixel.dist * delayPerDist;
          const pixelProgress = Math.max(0, (elapsed - pixelStart) / duration);
          if (pixelProgress > 0 && pixelProgress <= 1) {
            let scale;
            if (pixelProgress < 0.5) {
              scale = 1 + pixelProgress * 2; // Увеличение до 2x
            } else {
              scale = 2 - (pixelProgress - 0.5) * 2; // Уменьшение до 1x
            }
            // Цвет по кругам
            let color;
            if (pixel.dist <= 1) color = '#ffff00'; // Жёлтый для первого круга
            else if (pixel.dist <= 2) color = '#ff8000'; // Оранжевый для второго
            else color = '#654321'; // Тёмно-коричневый для третьего
            ctx.save();
            ctx.translate(pixel.x * pixelSize + pixelSize / 2, pixel.y * pixelSize + pixelSize / 2);
            ctx.scale(scale, scale);
            ctx.translate(-pixelSize / 2, -pixelSize / 2);
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, pixelSize, pixelSize);
            ctx.restore();
          }
        });

        if (progress < 1) {
          requestAnimationFrame(animate);
        }
      }
      requestAnimationFrame(animate);
    }

    // ==================== ИГРОВЫЕ ДЕЙСТВИЯ ====================
    function onCellAction(x, y) {
      if (timeLeft <= 0 || isPaused) return;
      const st = grid[y][x];
      if (st === RED || st === BLUE) { toWhite(x, y); afterChange(); }
      else if (st === BLACK) { toWhite(x, y); afterChange(); }
    }

    function onCellDrag(x, y) {
      if (!drawEnabled || isPaused) return; // Рисование работает если drawEnabled
      const st = grid[y][x];
      if (st === BLACK || (drawEnabled && (st === RED || st === BLUE))) {
        toWhite(x, y, true); // Эффекты срабатывают
        afterChange();
      }
    }

    function afterChange() {
      updateHUD();
      checkWin100();
      saveProgress();
    }

    // ==================== КРАСНЫЕ ПИКСЕЛИ (БОМБЫ) ====================
    function spawnBomb() {
      if (activeBombs.size >= 1) return;
      let x, y, ok = false, tries = 0;
      while (tries < 400 && !ok) {
        x = randInt(0, gridSize - 1);
        y = randInt(0, gridSize - 1);
        if (grid[y][x] === BLACK) ok = true;
        tries++;
      }
      if (!ok) return;
      grid[y][x] = RED;
      drawCell(x, y);
      const k = keyOf(x, y);
      const life = randInt(BOMB_LIFE_MS_MIN, BOMB_LIFE_MS_MAX);
      const tid = setTimeout(() => {
        if (grid[y][x] === RED) {
          activeBombs.delete(k);
          grid[y][x] = BLACK;
          drawCell(x, y);
        }
      }, life);
      activeBombs.set(k, tid);
    }

    function scheduleNextBomb() {
      const delay = randInt(BONUS_RESPAWN_MIN, BONUS_RESPAWN_MAX);
      bonusSpawnTimeout = setTimeout(() => { spawnBomb(); scheduleNextBomb(); }, delay);
    }

    // ==================== СИНИЕ ПИКСЕЛИ (БОНУС ВРЕМЕНИ) ====================
    function spawnBlue() {
      if (activeBlues.size >= 1) return;
      let x, y, ok = false, tries = 0;
      while (tries < 400 && !ok) {
        x = randInt(0, gridSize - 1);
        y = randInt(0, gridSize - 1);
        if (grid[y][x] === BLACK) ok = true;
        tries++;
      }
      if (!ok) return;
      grid[y][x] = BLUE;
      drawCell(x, y);
      const k = keyOf(x, y);
      const life = randInt(BLUE_LIFE_MS_MIN, BLUE_LIFE_MS_MAX);
      const tid = setTimeout(() => {
        if (grid[y][x] === BLUE) {
          activeBlues.delete(k);
          grid[y][x] = BLACK;
          drawCell(x, y);
        }
      }, life);
      activeBlues.set(k, tid);
    }

    function scheduleNextBlue() {
      const delay = randInt(BLUE_RESPAWN_MIN, BLUE_RESPAWN_MAX);
      blueSpawnTimeout = setTimeout(() => { spawnBlue(); scheduleNextBlue(); }, delay);
    }

    // ==================== ШУМ ====================
    function applyNoise(n) {
      let changed = 0, tries = 0;
      while (changed < n && tries < n * 80) {
        const x = randInt(0, gridSize - 1), y = randInt(0, gridSize - 1);
        if (grid[y][x] === WHITE) { toBlack(x, y); changed++; }
        tries++;
      }
      if (changed) updateHUD();
    }

    // ==================== ПОБЕДА ====================
    function checkWin100() {
      if (cleared >= totalPixels) endGame(true);
    }

    // ==================== ТАЙМЕР ====================
    function startTimer() {
      timerInterval = setInterval(() => {
        if (!isPaused) {
          timeLeft--;
          updateHUD();
          if (timeLeft <= 0) endGame(false);
        }
      }, 1000);
    }

    // ==================== ПАУЗА И СОХРАНЕНИЕ ====================
    function saveProgress() {
      localStorage.setItem('annoyingPixel', JSON.stringify({ grid, cleared, timeLeft, drawEnabled }));
    }

    function loadProgress() {
      const data = localStorage.getItem('annoyingPixel');
      if (data) {
        const parsed = JSON.parse(data);
        grid = parsed.grid;
        cleared = parsed.cleared;
        timeLeft = parsed.timeLeft;
        drawEnabled = parsed.drawEnabled !== undefined ? parsed.drawEnabled : true; // По умолчанию true
        drawGridFull();
        updateHUD();
      }
    }

    // ==================== КОНЕЦ ИГРЫ ====================
    function showCrack() {
      ctx.save();
      ctx.strokeStyle = 'rgba(220,220,220,0.9)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(60, 70); ctx.lineTo(180, 190); ctx.lineTo(320, 140);
      ctx.moveTo(40, 320); ctx.lineTo(160, 260); ctx.lineTo(260, 360);
      ctx.stroke();
      ctx.restore();
    }

    function resetGrid() {
      grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(BLACK));
      cleared = 0;
      drawEnabled = true; // По умолчанию
      if (drawEnableTimeout) { clearTimeout(drawEnableTimeout.id); drawEnableTimeout = null; }
      activeBombs.forEach(id => clearTimeout(id));
      activeBombs.clear();
      activeBlues.forEach(id => clearTimeout(id));
      activeBlues.clear();
    }

    function startGame() {
      clearInterval(timerInterval);
      clearInterval(noiseInterval);
      clearTimeout(bonusSpawnTimeout);
      clearTimeout(blueSpawnTimeout);
      activeBombs.forEach(id => clearTimeout(id));
      activeBombs.clear();
      activeBlues.forEach(id => clearTimeout(id));
      activeBlues.clear();
      resetGrid();
      hideMsg();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGridFull();
      timeLeft = GAME_TIME_SEC;
      isPaused = false;
      updateHUD();
      startTimer();
      noiseInterval = setInterval(() => applyNoise(NOISE_PER_SECOND), 1000);
      scheduleNextBomb();
      scheduleNextBlue();
      telegramMainButton(TEXTS[LANG].restart, () => startGame());
      render();
    }

    function endGame(win) {
      clearInterval(timerInterval);
      clearInterval(noiseInterval);
      clearTimeout(bonusSpawnTimeout);
      clearTimeout(blueSpawnTimeout);
      activeBombs.forEach(id => clearTimeout(id));
      activeBombs.clear();
      activeBlues.forEach(id => clearTimeout(id));
      activeBlues.clear();
      if (win) {
        showMsg(TEXTS[LANG].win);
        playSound(1000, 500); // Звук победы
      } else {
        showCrack();
        showMsg(TEXTS[LANG].gameOver);
      }
      updateHUD();
      telegramMainButton('Share Score', () => {
        const tg = window.Telegram && window.Telegram.WebApp;
        if (tg) {
          const data = JSON.stringify({ win, cleared: ((cleared / totalPixels) * 100).toFixed(1), timeLeft });
          tg.sendData(data);
        }
      });
      localStorage.removeItem('annoyingPixel');
    }

    // ==================== СОБЫТИЯ ====================
    canvas.addEventListener('pointerdown', (e) => {
      if (timeLeft <= 0 || isPaused) return;
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); // Разблокировка звука
      painting = true;
      canvas.setPointerCapture(e.pointerId);
      const { x, y } = getCellFromEvent(e);
      onCellAction(x, y);
      lastTime = Date.now(); // Инициализация для скорости
      lastX = x;
      lastY = y;
    });
    canvas.addEventListener('pointermove', (e) => {
      const { x, y } = getCellFromEvent(e);
      const now = Date.now();
      const dt = now - lastTime;
      if (dt > 0 && painting) {
        const speed = Math.sqrt((x - lastX) ** 2 + (y - lastY) ** 2) / dt; // Скорость в пикселях/мс
        if (now - lastSoundTime > SOUND_THROTTLE_MS) {
          const frequency = BASE_FREQ + speed * SPEED_MULTIPLIER;
          playSound(frequency, 100);
          lastSoundTime = now;
        }
      }
      lastTime = now;
      lastX = x;
      lastY = y;
      if (!painting) return;
      onCellDrag(x, y);
    });
    canvas.addEventListener('pointerup', () => { painting = false; });
    canvas.addEventListener('pointercancel', () => { painting = false; });

    restartBtn.addEventListener('click', () => startGame());

    // ==================== TELEGRAM ====================
    function telegramMainButton(text, onClick) {
      const tg = window.Telegram && window.Telegram.WebApp;
      if (!tg) return;
      tg.MainButton.hide();
      tg.MainButton.setText(text);
      tg.MainButton.show();
      if (tg.MainButton.offClick) tg.MainButton.offClick();
      tg.MainButton.onClick(onClick);
    }

    function integrateWithTelegram() {
      const tg = window.Telegram && window.Telegram.WebApp;
      if (!tg) return;
      tg.ready();
      tg.expand();
      const bg = tg.themeParams?.bg_color;
      if (bg) document.body.style.background = `#${bg}`;
      telegramMainButton(TEXTS[LANG].restart, () => startGame());
    }

    // ==================== ИНИЦИАЛИЗАЦИЯ ====================
    (function init() {
      setupHiDPI();
      resetGrid();
      drawGridFull();
      updateHUD();
      integrateWithTelegram();
      loadProgress();
      startGame();
      window.addEventListener('resize', setupHiDPI);
    })();
  </script>
</body>
</html>
