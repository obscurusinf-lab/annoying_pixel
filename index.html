<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Annoying Pixel ‚Äî TG WebApp</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0; padding: 16px;
      font-family: Arial, Helvetica, sans-serif;
      text-align: center;
      user-select: none; -webkit-user-select: none;
      background: #f6f6f6;
      transition: background 0.3s;
      position: fixed; /* –§–∏–∫—Å–∏—Ä—É–µ–º –¥–ª—è Telegram */
      top: 0; left: 0; right: 0; bottom: 0;
      overflow: hidden; /* –û—Ç–∫–ª—é—á–∞–µ–º —Å–∫—Ä–æ–ª–ª */
    }
    #hud { margin: 6px auto 10px; font-size: 14px; }
    .btns { margin: 8px 0 14px; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }
    button {
      cursor: pointer; padding: 8px 12px; border-radius: 8px;
      border: 1px solid #999; background: #fff; font-size: 14px;
    }
    button:disabled { opacity: .5; cursor: not-allowed; }
    #container { display: inline-block; position: relative; max-width: 100%; }
    canvas { border: 1px solid #000; touch-action: none; background: #000; display: block; max-width: 100%; height: auto; }
    #message {
      position: absolute; inset: 0; display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.4); color: #fff; font-size: 22px; font-weight: 700;
      text-shadow: 0 1px 2px #000; padding: 16px;
      backdrop-filter: blur(2px); -webkit-backdrop-filter: blur(2px);
    }
    @supports not (backdrop-filter: blur(2px)) {
      #message { background: rgba(0,0,0,0.8); }
    }
    #leaderboard { display: none; position: absolute; inset: 0; background: rgba(0,0,0,0.8); color: #fff; padding: 20px; overflow-y: auto; }
    #multiplayerHud { margin: 4px auto; font-size: 12px; color: #666; }
  </style>
</head>
<body>
  <div id="hud">‚Äî</div>
  <div id="multiplayerHud">–ò–≥—Ä–æ–∫ 1: 0 –æ—á–∫–æ–≤ | –•–æ–¥: –ò–≥—Ä–æ–∫ 1</div>
  <div class="btns">
    <button id="restartBtn" title="–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫">‚ü≤</button>
    <button id="leaderboardBtn" title="–†–µ–∫–æ—Ä–¥—ã">üèÜ</button>
    <button id="switchPlayerBtn" title="–°–º–µ–Ω–∏—Ç—å –∏–≥—Ä–æ–∫–∞">üîÑ</button>
  </div>

  <div id="container">
    <canvas id="game" width="400" height="400"></canvas>
    <div id="message"></div>
    <div id="leaderboard"></div>
  </div>

  <script>
    // ==================== –ö–û–ù–°–¢–ê–ù–¢–´ ====================
    const BLACK = 0, WHITE = 1, RED = 2, BLUE = 3, YELLOW = 4;
    const gridSize = 50;
    const pixelSize = 8;
    const totalPixels = gridSize * gridSize;
    const GAME_TIME_SEC = 180;
    const DRAW_WINDOW_MS = 20000;
    const RED_LIFE_MS_MIN = 1500;
    const RED_LIFE_MS_MAX = 3000;
    const RED_RESPAWN_MIN = 1200;
    const RED_RESPAWN_MAX = 2400;
    const BLUE_LIFE_MS_MIN = 2000;
    const BLUE_LIFE_MS_MAX = 4000;
    const YELLOW_LIFE_MS_MIN = 3000;
    const YELLOW_LIFE_MS_MAX = 5000;
    const BONUS_RESPAWN_MIN = 5000;
    const BONUS_RESPAWN_MAX = 10000;
    const NOISE_PER_SECOND = 3;
    const LANG = navigator.language.startsWith('ru') ? 'ru' : 'en';
    const TEXTS = {
      ru: { win: '–ü–û–ë–ï–î–ê!', gameOver: '–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê', restart: '‚ü≤', leaderboard: 'üèÜ', enterName: '–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–∏–∫ (–º–∞–∫—Å. 20 —Å–∏–º–≤–æ–ª–æ–≤):', records: '–†–µ–∫–æ—Ä–¥—ã:', player: '–ò–≥—Ä–æ–∫', turn: '–•–æ–¥:', points: '–æ—á–∫–æ–≤' },
      en: { win: 'WIN!', gameOver: 'GAME OVER', restart: '‚ü≤', leaderboard: 'üèÜ', enterName: 'Enter your nickname (max 20 chars):', records: 'Records:', player: 'Player', turn: 'Turn:', points: 'points' }
    };

    // ==================== –ö–õ–ê–°–°–´ ====================
    class PixelGrid {
      constructor(canvas, ctx) {
        this.canvas = canvas;
        this.ctx = ctx;
        this.grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(BLACK));
        this.dirtyCells = new Set(); // –î–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —Ä–µ–Ω–¥–µ—Ä–∞
      }

      get(x, y) { return this.grid[y][x]; }
      set(x, y, val) { this.grid[y][x] = val; this.dirtyCells.add(`${x},${y}`); }

      drawCell(x, y) {
        const st = this.get(x, y);
        this.ctx.fillStyle = st === BLACK ? '#000' : st === WHITE ? '#fff' : st === RED ? '#e10600' : st === BLUE ? '#0066ff' : '#ffff00';
        this.ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
      }

      renderDirty() {
        this.dirtyCells.forEach(key => {
          const [x, y] = key.split(',').map(Number);
          this.drawCell(x, y);
        });
        this.dirtyCells.clear();
      }

      reset() {
        this.grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(BLACK));
        this.dirtyCells.clear();
      }
    }

    class SoundManager {
      constructor() {
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }

      play(frequency, duration = 200) {
        if (!this.audioCtx) return;
        const oscillator = this.audioCtx.createOscillator();
        const gainNode = this.audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(this.audioCtx.destination);
        oscillator.frequency.setValueAtTime(frequency, this.audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.1, this.audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + duration / 1000);
        oscillator.start(this.audioCtx.currentTime);
        oscillator.stop(this.audioCtx.currentTime + duration / 1000);
      }
    }

    class Timer {
      constructor() {
        this.timers = new Map();
      }

      setTimeout(key, fn, delay) {
        this.clear(key);
        this.timers.set(key, setTimeout(fn, delay));
      }

      setInterval(key, fn, delay) {
        this.clear(key);
        this.timers.set(key, setInterval(fn, delay));
      }

      clear(key) {
        if (this.timers.has(key)) {
          clearTimeout(this.timers.get(key));
          clearInterval(this.timers.get(key));
          this.timers.delete(key);
        }
      }

      clearAll() {
        this.timers.forEach((id) => { clearTimeout(id); clearInterval(id); });
        this.timers.clear();
      }
    }

    class Analytics {
      track(event, data = {}) {
        const tg = window.Telegram && window.Telegram.WebApp;
        if (tg && tg.sendData) {
          tg.sendData(JSON.stringify({ event, ...data, timestamp: Date.now() }));
        }
        console.log('Analytics:', event, data); // Fallback –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
      }
    }

    class TelegramIntegration {
      constructor() {
        this.tg = window.Telegram && window.Telegram.WebApp;
        if (this.tg) {
          this.tg.ready();
          this.tg.expand();
          const bg = this.tg.themeParams?.bg_color;
          if (bg) document.body.style.background = `#${bg}`;
        }
      }

      setMainButton(text, onClick) {
        if (!this.tg) return;
        this.tg.MainButton.hide();
        this.tg.MainButton.setText(text);
        this.tg.MainButton.show();
        if (this.tg.MainButton.offClick) this.tg.MainButton.offClick();
        this.tg.MainButton.onClick(onClick);
      }
    }

    class Game {
      constructor(pixelGrid, soundManager, timer, analytics, telegram) {
        this.pixelGrid = pixelGrid;
        this.sound = soundManager;
        this.timer = timer;
        this.analytics = analytics;
        this.telegram = telegram;
        this.cleared = 0;
        this.timeLeft = 0;
        this.painting = false;
        this.drawEnabled = false;
        this.drawEnableTimeout = null;
        this.playerName = localStorage.getItem('playerName') || '';
        this.startTime = 0;
        this.activeReds = new Map();
        this.activeBlues = new Map();
        this.activeYellows = new Map();
        // –ú—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä
        this.players = [{ name: TEXTS[LANG].player + ' 1', points: 0 }, { name: TEXTS[LANG].player + ' 2', points: 0 }];
        this.currentPlayer = 0;
        this.multiplayer = false; // –í–∫–ª—é—á–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–π –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä
      }

      updateHUD() {
        const pct = ((this.cleared / totalPixels) * 100).toFixed(1);
        const m = Math.floor(this.timeLeft / 60), s = this.timeLeft % 60;
        const t = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        const pen = this.drawEnabled ? ` ‚úèÔ∏è${Math.ceil(this.remainingDrawSeconds())}s` : '';
        hudEl.textContent = `${pct}%  ‚è± ${t}${pen}`;
        if (this.multiplayer) {
          multiplayerHudEl.textContent = `${this.players[0].name}: ${this.players[0].points} ${TEXTS[LANG].points} | ${this.players[1].name}: ${this.players[1].points} ${TEXTS[LANG].points} | ${TEXTS[LANG].turn} ${this.players[this.currentPlayer].name}`;
        }
      }

      remainingDrawSeconds() {
        if (!this.drawEnabled || !this.drawEnableTimeout || !this.drawEnableTimeout.when) return 0;
        return Math.max(0, this.drawEnableTimeout.when - Date.now()) / 1000;
      }

      toWhite(x, y) {
        const st = this.pixelGrid.get(x, y);
        if (st === WHITE) return false;
        if (st === RED) {
          const id = this.activeReds.get(keyOf(x, y));
          if (id) { this.timer.clear(id); this.activeReds.delete(keyOf(x, y)); }
          this.activateDrawWindow();
          this.sound.play(800);
        } else if (st === BLUE) {
          const id = this.activeBlues.get(keyOf(x, y));
          if (id) { this.timer.clear(id); this.activeBlues.delete(keyOf(x, y)); }
          this.timeLeft += 3;
          this.sound.play(400);
        } else if (st === YELLOW) {
          const id = this.activeYellows.get(keyOf(x, y));
          if (id) { this.timer.clear(id); this.activeYellows.delete(keyOf(x, y)); }
          this.explodeYellow(x, y);
          this.sound.play(200, 500);
        }
        this.pixelGrid.set(x, y, WHITE);
        this.cleared++;
        if (st !== BLUE && st !== YELLOW) this.sound.play(600);
        if (this.multiplayer) this.players[this.currentPlayer].points += 1;
        return true;
      }

      explodeYellow(cx, cy) {
        for (let dy = -3; dy <= 3; dy++) {
          for (let dx = -3; dx <= 3; dx++) {
            if (dx * dx + dy * dy <= 9) {
              const nx = cx + dx, ny = cy + dy;
              if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && this.pixelGrid.get(nx, ny) !== WHITE) {
                this.toWhite(nx, ny);
              }
            }
          }
        }
      }

      activateDrawWindow() {
        this.drawEnabled = true;
        if (this.drawEnableTimeout) this.timer.clear(this.drawEnableTimeout.id);
        const when = Date.now() + DRAW_WINDOW_MS;
        const id = this.timer.setTimeout('drawWindow', () => { this.drawEnabled = false; this.updateHUD(); }, DRAW_WINDOW_MS);
        this.drawEnableTimeout = { id, when };
        this.updateHUD();
      }

      spawnRed() {
        if (this.activeReds.size >= 5) return; // –£–≤–µ–ª–∏—á–∏–ª –ª–∏–º–∏—Ç
        let x, y, ok = false, tries = 0;
        while (tries < 400 && !ok) {
          x = randInt(0, gridSize - 1);
          y = randInt(0, gridSize - 1);
          if (this.pixelGrid.get(x, y) === BLACK) ok = true;
          tries++;
        }
        if (!ok) return;
        this.pixelGrid.set(x, y, RED);
        const k = keyOf(x, y);
        const life = randInt(RED_LIFE_MS_MIN, RED_LIFE_MS_MAX);
        const tid = this.timer.setTimeout(`red_${k}`, () => {
          if (this.pixelGrid.get(x, y) === RED) {
            this.activeReds.delete(k);
            this.pixelGrid.set(x, y, BLACK);
            const dirs = [[0,0],[1,0],[-1,0],[0,1],[0,-1]];
            dirs.forEach(([dx, dy]) => {
              const nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) this.toBlack(nx, ny);
            });
            this.updateHUD();
          }
        }, life);
        this.activeReds.set(k, tid);
      }

      spawnBonus() {
        const type = Math.random() < 0.5 ? BLUE : YELLOW;
        const activeMap = type === BLUE ? this.activeBlues : this.activeYellows;
        if ((type === BLUE && this.activeBlues.size >= 2) || (type === YELLOW && this.activeYellows.size >= 1)) return;
        let x, y, ok = false, tries = 0;
        while (tries < 400 && !ok) {
          x = randInt(0, gridSize - 1);
          y = randInt(0, gridSize - 1);
          if (this.pixelGrid.get(x, y) === BLACK) ok = true;
          tries++;
        }
        if (!ok) return;
        this.pixelGrid.set(x, y, type);
        const k = keyOf(x, y);
        const life = randInt(type === BLUE ? BLUE_LIFE_MS_MIN : YELLOW_LIFE_MS_MIN, type === BLUE ? BLUE_LIFE_MS_MAX : YELLOW_LIFE_MS_MAX);
        const tid = this.timer.setTimeout(`bonus_${k}`, () => {
          if (this.pixelGrid.get(x, y) === type) {
            activeMap.delete(k);
            this.pixelGrid.set(x, y, BLACK);
          }
        }, life);
        activeMap.set(k, tid);
      }

      toBlack(x, y) {
        const st = this.pixelGrid.get(x, y);
        if (st === WHITE) this.cleared = Math.max(0, this.cleared - 1);
        if (st === RED) {
          const id = this.activeReds.get(keyOf(x, y));
          if (id) { this.timer.clear(id); this.activeReds.delete(keyOf(x, y)); }
        } else if (st === BLUE) {
          const id = this.activeBlues.get(keyOf(x, y));
          if (id) { this.timer.clear(id); this.activeBlues.delete(keyOf(x, y)); }
        } else if (st === YELLOW) {
          const id = this.activeYellows.get(keyOf(x, y));
          if (id) { this.timer.clear(id); this.activeYellows.delete(keyOf(x, y)); }
        }
        this.pixelGrid.set(x, y, BLACK);
      }

      applyNoise(n) {
        let changed = 0, tries = 0;
        while (changed < n && tries < n * 80) {
          const x = randInt(0, gridSize - 1), y = randInt(0, gridSize - 1);
          if (this.pixelGrid.get(x, y) === WHITE) { this.toBlack(x, y); changed++; }
          tries++;
        }
        if (changed) this.updateHUD();
      }

      checkWin100() {
        if (this.cleared >= totalPixels) this.endGame(true);
      }

      onCellAction(x, y) {
        if (this.timeLeft <= 0) return;
        const st = this.pixelGrid.get(x, y);
        if (st === RED || st === BLUE || st === YELLOW) { this.toWhite(x, y); this.afterChange(); }
        else if (st === BLACK) { this.toWhite(x, y); this.afterChange(); }
        this.analytics.track('cell_click', { x, y, state: st });
      }

      onCellDrag(x, y) {
        if (!this.drawEnabled) return;
        if (this.pixelGrid.get(x, y) === BLACK) { this.toWhite(x, y); this.afterChange(); }
      }

      afterChange() {
        this.pixelGrid.renderDirty();
        this.updateHUD();
        this.checkWin100();
        if (navigator.vibrate) navigator.vibrate(50); // –í–∏–±—Ä–∞—Ü–∏—è
      }

      switchPlayer() {
        this.currentPlayer = (this.currentPlayer + 1) % 2;
        this.updateHUD();
      }

      startGame() {
        if (!this.playerName) {
          this.playerName = prompt(TEXTS[LANG].enterName, '').trim().replace(/[^a-zA-Z0-9]/g, '').substring(0, 20);
          if (!this.playerName) this.playerName = 'Player';
          localStorage.setItem('playerName', this.playerName);
        }
        this.timer.clearAll();
        this.pixelGrid.reset();
        this.cleared = 0;
        this.drawEnabled = false;
        if (this.drawEnableTimeout) { this.timer.clear(this.drawEnableTimeout.id); this.drawEnableTimeout = null; }
        this.activeReds.clear();
        this.activeBlues.clear();
        this.activeYellows.clear();
        hideMsg();
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.pixelGrid.grid.forEach((row, y) => row.forEach((_, x) => this.pixelGrid.drawCell(x, y)));
        this.timeLeft = GAME_TIME_SEC;
        this.startTime = Date.now();
        this.updateHUD();
        this.timer.setInterval('timer', () => {
          this.timeLeft--;
          this.updateHUD();
          if (this.timeLeft <= 0) this.endGame(false);
        }, 1000);
        this.timer.setInterval('noise', () => this.applyNoise(NOISE_PER_SECOND), 1000);
        this.scheduleSpawns();
        this.telegram.setMainButton(TEXTS[LANG].restart, () => this.startGame());
        this.analytics.track('game_start');
      }

      scheduleSpawns() {
        const scheduleRed = () => {
          const delay = randInt(RED_RESPAWN_MIN, RED_RESPAWN_MAX);
          this.timer.setTimeout('red_spawn', () => { this.spawnRed(); scheduleRed(); }, delay);
        };
        const scheduleBonus = () => {
          const delay = randInt(BONUS_RESPAWN_MIN, BONUS_RESPAWN_MAX);
          this.timer.setTimeout('bonus_spawn', () => { this.spawnBonus(); scheduleBonus(); }, delay);
        };
        scheduleRed();
        scheduleBonus();
      }

      endGame(win) {
        this.timer.clearAll();
        this.activeReds.clear();
        this.activeBlues.clear();
        this.activeYellows.clear();
        if (win) {
          const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
          this.saveRecord(elapsed);
          showMsg(`${TEXTS[LANG].win} (${elapsed}s)`);
          this.sound.play(1000, 500);
          this.analytics.track('game_win', { time: elapsed });
        } else {
          this.showCrack();
          showMsg(TEXTS[LANG].gameOver);
          this.analytics.track('game_over');
        }
        this.updateHUD();
        this.telegram.setMainButton(TEXTS[LANG].restart, () => this.startGame());
      }

      showCrack() {
        this.ctx.save();
        this.ctx.strokeStyle = 'rgba(220,220,220,0.9)';
        this.ctx.lineWidth = 4;
        this.ctx.beginPath();
        this.ctx.moveTo(60, 70); this.ctx.lineTo(180, 190); this.ctx.lineTo(320, 140);
        this.ctx.moveTo(40, 320); this.ctx.lineTo(160, 260); this.ctx.lineTo(260, 360);
        this.ctx.stroke();
        this.ctx.restore();
      }

      saveRecord(time) {
        const records = JSON.parse(localStorage.getItem('records') || '[]');
        records.push({ name: this.playerName, time });
        records.sort((a, b) => a.time - b.time);
        localStorage.setItem('records', JSON.stringify(records.slice(0, 5)));
      }
    }

    // ==================== DOM –ò –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ====================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hudEl = document.getElementById('hud');
    const multiplayerHudEl = document.getElementById('multiplayerHud');
    const restartBtn = document.getElementById('restartBtn');
    const leaderboardBtn = document.getElementById('leaderboardBtn');
    const switchPlayerBtn = document.getElementById('switchPlayerBtn');

    const pixelGrid = new PixelGrid(canvas, ctx);
    const soundManager = new SoundManager();
    const timer = new Timer();
    const analytics = new Analytics();
    const telegram = new TelegramIntegration();
    const game = new Game(pixelGrid, soundManager, timer, analytics, telegram);

    // –£—Ç–∏–ª–∏—Ç—ã
    const keyOf = (x, y) => y * gridSize + x;
    const randInt = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

    // HiDPI
    function setupHiDPI() {
      const dpr = window.devicePixelRatio || 1;
      const containerWidth = Math.min(window.innerWidth - 32, 600);
      const scale = Math.max(containerWidth / (gridSize * pixelSize), 0.75);
      const scaledSize = (gridSize * pixelSize) * scale;
      canvas.style.width = scaledSize + 'px';
      canvas.style.height = scaledSize + 'px';
      canvas.width = Math.floor(scaledSize * dpr);
      canvas.height = Math.floor(scaledSize * dpr);
      ctx.setTransform(dpr * scale, 0, 0, dpr * scale, 0, 0);
    }

    function getCellFromEvent(e) {
      const rect = canvas.getBoundingRect();
      const scaleX = (gridSize * pixelSize) / rect.width;
      const scaleY = (gridSize * pixelSize) / rect.height;
      const cx = Math.floor(((e.clientX - rect.left) * scaleX) / pixelSize);
      const cy = Math.floor(((e.clientY - rect.top) * scaleY) / pixelSize);
      return { x: clamp(cx, 0, gridSize - 1), y: clamp(cy, 0, gridSize - 1) };
    }

    function showMsg(text) { msgEl.textContent = text; msgEl.style.display = 'flex'; }
    function hideMsg() { msgEl.style.display = 'none'; msgEl.textContent = ''; }

    function showLeaderboard() {
      const records = JSON.parse(localStorage.getItem('records') || '[]');
      let html = `<h2>${TEXTS[LANG].records}</h2><ol>`;
      records.forEach(r => html += `<li>${r.name}: ${r.time}s</li>`);
      html += '</ol><button onclick="hideLeaderboard()">–ó–∞–∫—Ä—ã—Ç—å</button>';
      leaderboardEl.innerHTML = html;
      leaderboardEl.style.display = 'flex';
    }

    function hideLeaderboard() { leaderboardEl.style.display = 'none'; }

    // –°–æ–±—ã—Ç–∏—è
    canvas.addEventListener('pointerdown', (e) => {
      e.preventDefault(); // –§–∏–∫—Å –¥–ª—è Telegram
      if (game.timeLeft <= 0) return;
      game.painting = true;
      canvas.setPointerCapture(e.pointerId);
      const { x, y } = getCellFromEvent(e);
      game.onCellAction(x, y);
    });
    canvas.addEventListener('pointermove', (e) => {
      e.preventDefault(); // –§–∏–∫—Å –¥–ª—è Telegram
      if (!game.painting) return;
      const { x, y } = getCellFromEvent(e);
      game.onCellDrag(x, y);
    });
    canvas.addEventListener('pointerup', () => { game.painting = false; });
    canvas.addEventListener('pointercancel', () => { game.painting = false; });

    restartBtn.addEventListener('click', () => game.startGame());
    leaderboardBtn.addEventListener('click', () => showLeaderboard());
    switchPlayerBtn.addEventListener('click', () => game.switchPlayer());

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    (function init() {
      setupHiDPI();
      pixelGrid.reset();
      pixelGrid.grid.forEach((row, y) => row.forEach((_, x) => pixelGrid.drawCell(x, y)));
      game.updateHUD();
      telegram.setMainButton(TEXTS[LANG].restart, () => game.startGame());
      window.addEventListener('resize', setupHiDPI);
      game.startGame();
    })();
  </script>
</body>
</html>
